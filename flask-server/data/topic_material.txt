Topic: Polymorphism in Java, Abstract classes, Interfaces
In the previous lectures you learned how to create and use new classes (data abstraction), and how to derive a class from an existing class (inheritance). In this lecture we will learn about Polymorphism, which is the third essential feature of OOP programming. While the inheritance promotes reusability, the polymorphism allows developers to write code that does not depend on a specific type of objects. Polymorphic behavior In the BasePlusCommisionEmployee	CommissionEmployee example, you noticed that method toString() behaved differently when we applied that method to different objects (CommissionEmployee and BasePlusCommisionEmployee). When a method behaves differently when it’s applied to different objects, this is called a polymorphic behavior. In a large number of problems there is always a situation, in which for a given entity you may define a generic behavior, and then
redefine it for more specialized entities that represent more specific set of objects. Abstract classes The most typical example that many authors use to illustrate the polymorphism is the hierarchy of shapes. Every specific shape such as a line, a rectangle and an oval must have a drawing behavior. The classes that represent those shapes must contain a method that draws the individual shape. If we consider only the set of two-dimensional shapes, then all those classes should also contain properties that describe the coordinates and the dimensions of each shape. To achieve reusability is better to start the hierarchy of two-dimensional shapes with a superclass that represents the most general characteristics of shapes and derive all other specific classes from that superclass. The only problem that may arise here is: What implementation should we provide for the drawing method of the superclass? Let’s name the superclass Shape. Java provides a special construction called abstract classes that can be used to describe incomplete features. An abstract class is an incomplete Java class. It may contain methods with a complete implementation. But any abstract class must contain an abstract method, which means a method with no implementation. For example the following class is declared abstract and contains an abstract method called drawShape: import java.awt.Graphics; //definition of abstract superclass Shape public abstract class Shape { protected int x1, y1 , x2, y2; public void setCoordinates(int x1, int y1, int x2, int y2) { this.x1=x1; this.y1=y1; this.x2=x2; this.y2=y2; } //abstract method public abstract void drawShape(Graphics g); } // end of Shape The drawShape method has no implementation. The class Line derives from class Shape: import java.awt.*; //definition of class Line public class Line extends Shape {
//no argument constructor public Line() {setCoordinates(0,0,0,0);} //four - constructor public Line(int x1, int y1, int x2, int y2) { setCoordinates(x1, y1, x2, y2); } //override the abstract method public void drawShape(Graphics g) { g.setColor(Color.blue); g.drawLine(x1,y1,x2,y2); } } // end of Line Class Line provides an implementation of drawShape. Another class, Rectangle derives from Shape and provides another implementation of drawShape method: import java.awt.*; //definition of class Rectangle public class Rectangle extends Shape { //no argument constructor public Rectangle() {setCoordinates(0,0,0,0);}
//constructor public Rectangle(int x1, int y1, int x2, int y2) {setCoordinates(x1, y1, x2, y2);} public void drawShape(Graphics g) { g.setColor(Color.blue); //calculate width and height int width=Math.abs(x2-x1); int height=Math.abs(y2-y1); g.fillRect(x1,y1,width,height); } } A class that tests this hierarchy of Shapes must instantiate Line objects or Rectangle objects and invoke method drawShape to draw them as in the following statements: l = new Line(x1, y1, x2, y2); r = new Rectangle(x1, y1, x2, y2);	r.drawShape(g);
l.drawShape(g); Here is an application that tests the hierarchy of shapes: import javax.swing.*; import java.awt.*; public class TestShapes extends JPanel{ public void paintComponent(Graphics g) { super.paintComponent(g); Line l = new Line(20, 20, 200, 200); Rectangle r = new Rectangle(30, 30, 300, 300); r.drawShape(g); l.drawShape(g); } public static void main(String[] args) { JFrame frame = new JFrame(); frame.setSize(500,500); TestShapes ts = new TestShapes(); frame.getContentPane().add(ts);
 
frame.setVisible(true); } } Figure 5.1 Drawing polymorphically a line and a rectangle Calling subclass methods on superclass objects Sometimes is useful to have superclass references invoke subclass methods. For example you can have: Shape s; . . s=l; s.drawShape(g); The method drawShape will draw a line because s references an object of type Line. The binding of s to the right method takes place at run- time. Providing different implementations of method drawShape in Shapes’s subclasses is called polymorphism. The actual act of redefining the abstract method in subclasses is called overriding. Thus, in order to implement the polymorphism you should override abstract methods of the superclass in subclasses. Interfaces in Java Interfaces are another great feature of Java. The concept is used in other programming languages such as C++, but has certainly a better implementation in Java. When you learned about abstract classes, you noticed that an abstract class must contain at least an abstract method. But abstract classes may contain methods with a complete implementation. The main use of abstract classes is in implementing polymorphism by designing a hierarchy of classes which is usually headed by an abstract superclass and letting the subclasses to implement abstract behaviors. The subclasses can inherit the public and protected members of the superclass. The most important thing in this process is that they inherit some existing implementation. Whereas this is good in some cases it might not be useful in other cases. For example most of the distributed object technologies such as CORBA and RMI use the declaration of services as the only point of contact between the client program and the server program. This brings flexibility and speeds up the development process. Java provides a special construction called interface that allows the developers to declare a set of methods without implementation. A Java interface has the following syntax: public interface InterfaceName { // final variables declarations . . // method declarations AccessModifier abstract returnType methodName(list of parameters); . . } The first thing that you may notice is the absence of any implementation. An interface can also include constant declarations. What are interfaces used for? According to Java Language specifications interfaces are useful for: • Capturing similarities between unrelated classes
without artificially forcing a class relationship • Declaring methods that one or more classes are
expected to implement • Revealing an object's programming interface without revealing its class. (Objects such as these are called anonymous objects and can be useful when shipping a package of classes to other developers.) The hierarchy headed by Shapes class in the previous lecture could also be designed by using an interface instead of an abstract class: interface Shape { public abstract void drawShape(Graphics g); } The class Line must implement interface Shapes as in the following: class Line implements Shape { public void drawShape(Graphics g) { // code to draw the line } } Java allows classes to implement multiple interfaces by using a comma-separated list as in the following: public class C
implements interface I1, I2,…..IN { . //implementation of I1 methods . //Implementation of I2 methods . .
} The following example uses the interface Payable to declare the getPaymentAmount method: public interface Payable { double getPaymentAmount(); // calculate payment; no implementation } Class Employee is an abstract class that implements Payable interface. As you see here, there is no implementation of getPaymentAmount method in this class: abstract class Employee implements Payable{ //instance variables private String name; //describes the name property private String sin;
//describes the salary property //class constructor public Employee(String n, String s) { name = n; sin = s;
} public String getName() // reads salary { return name; } public void setName(String n) // sets salary { name = n; } public String getSin() // reads salary { return sin; } public void setSin(String s) // sets salary { sin = s; } public String toString() { return name + ", " + sin; } } //end of class Class Developer is a concrete subclass of Employee. The Developer class provides an implementation of getPaymentAmout method, in which it returns developer’s salary: public class Developer extends Employee{ private double salary; //
 
four-argument constructor public Developer( String name, String sin, double salary ) { super( name,sin );
// pass to Employee constructor this.salary= salary ; // store salary } // set salary public void setSalary( double salary ) { this.salary = salary < 0.0 ? 0.0 : salary; } // return salary public double getSalary() { return salary; } // implement interface Payable method that was // abstract in superclass Employee public double getPaymentAmount() { return getSalary(); } // return String representation of Developer object public String toString() { return super.toString()+ ", monthly salary: " +salary; } } Class Invoice, also implements Payable interface, and provides another implementation of getPaymentAmount method: public class Invoice implements Payable { private String partNumber; private String partDescription; private int quantity; private double pricePerItem; // four-argument constructor public Invoice( String part, String description, int count, double price ) { partNumber = part; partDescription = description; setQuantity( count ); // validate and store quantity setPricePerItem( price ); // validate and store price per item } // end four-argument Invoice constructor // set part number public void setPartNumber( String part ) { partNumber = part; } // get part number public String getPartNumber() { return partNumber; } // set description public void setPartDescription( String description ) { partDescription = description; } // get description public String getPartDescription() { return partDescription; } // set quantity public void setQuantity( int count ) { quantity = ( count < 0 ) ? 0 : count; // quantity cannot be negative } // get quantity public int getQuantity() { return quantity; } // set price per item public void setPricePerItem( double price ) { pricePerItem = ( price < 0.0 ) ? 0.0 : price; // validate price } // get price per item public double getPricePerItem() { return pricePerItem; } // return String representation of Invoice object public String toString() { return "part number: "+ getPartNumber()+", part description: " + getPartDescription() +", quantity: "+ getQuantity()+ ", price per item: " + getPricePerItem() ; } // method required to carry out contract with interface Payable public double getPaymentAmount() { return getQuantity() * getPricePerItem(); // calculate total cost } } // end class Invoice Here is an application that uses Payable interface. It creates four different objects (two invoices and two developers) and it displays the amounts for each of them. As you can see, getPaymentAmount method returns invoice’s amount or developer’s salary depending on which object is being called: public class TestPayableInterface { public static void main( String args[] ) { // create four-element Payable array Payable pObj[] = new Payable[ 4 ]; // populate array with objects that implement Payable pObj[ 0 ] = new Invoice( "01234", "256Mb RAM", 2, 29.99 ); pObj[ 1 ] = new Invoice( "01235", "Wireless card", 4,
79.95 ); pObj[ 2 ] = new Developer( "David Mitchel", "123-456-789", 800.00 ); pObj[ 3 ] = new Developer( "Carol Fisher", "345-123-987", 1200.00 ); System.out.println( "Invoices and Employees processed polymorphically:\n" ); // generically process each element in array payableObjects for ( int i=0;i<pObj.length;i++) { // output currentPayable and its appropriate payment amount System.out.println( pObj[i].toString()+ "\n" + "payment due: "+ pObj[i].getPaymentAmount()) ; } // end for } // end main }
